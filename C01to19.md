# 鉄則本の力試し問題を解いてみた

「競技プログラミングの鉄則 ～アルゴリズムと思考力を高める 77 の技術～」(米田優峻 著, 2022/9, マイナビ出版)、通称鉄則本の力試し問題(C01..19)を私がACした解法です。著者のサイトは[こちら](https://github.com/E869120/kyopro-tessoku)です。自動採点システムは[こちら](https://atcoder.jp/contests/tessoku-book)です。

## 概要

- 正解がある問題(C01..C19)を実装して、全問ACしたことを確認済です。問題番号 `id` のソースコードはこのレポジトリの `id.cpp` です。自動採点システムの結果へのリンクは、ソースコードの先頭行にあります。
- C20はヒューリスティック型課題なので正解というものはありません。改善あるのみです。私はまだ解いていないので後で解きます。
- C18以外(C01..17,19)を私は解説を見ずに解いたので、まだ公式の解説を読んでいません。ですのでこの解説には拙い部分が多々あるでしょう。
- C18を私は解けなかったので、公式の解答を読んで解きました。
- C12,C16の実装で計算量が多いのと、C19で局所最適が全体最適であることの証明は改善の余地があります。
- 文中において、1..Nは1からNまでの整数です。1とNの両方を含みます。

## 各問

### C01

最初の問題は、標準入出力の使い方を覚える練習です。入力が100の倍数なので、1.1倍しても整数であることが保証されます。ここで敢えて浮動小数を使わず、11倍して10で割るとよいでしょう。Nが最大$10^6$なので、intでもオーバフローしませんが、int (PCなら32-bitのことが多い)ではなくlong long int (少なくとも64-bit)を一貫して使う方が、オーバフローに気を使わなくていいです。

浮動小数を使わずに、整数を乗算して除算するアイデアは、C11で生きます。

### C02

ボールを一個ずつ見て行って、一番目に重いボールの重さと、二番目に重いボールの重さを更新すればよいです。最後に両方の重さを足します。これで$O(N)$です。

- 一番目と二番目に重さの初期値は0とします。ボールは少なくとも2個あり、ボールの重さは少なくとも1ありますので、いつか0は上書きされます。
- 一番目に重いボールの重さと、二番目に重いボールの重さは同じかもしれません

### C03

累積和(A06)を求めましょう、と問題文が語っているようです。前日との株価の差分を入力するごとにことに今日の株価が求まるので$O(D)$、株価を1問い合わせごとに$O(1)$で求めると、Q回の問い合わせは$O(Q)$で求まります。

### C04

$sqrt(1..N)$の約数を求めれば、対になる約数も求まります。平方数つまり$sqrt(1..N)$が整数の場合を二度列挙しないように注意します。

それとループを回すときは、$i<=sqrt(N)$より$(i*i)<=N$の方が、浮動小数演算の誤差の影響を受けないのと、計算が速いという二点から望ましいです。このときはオーバフローに注意しましょう。

### C05

4と7をそれぞれ0と1に置き換えると、ビット全探索(1章のコラム2)の要領です。10進数を2進数に変換し、0を4に、1を7に置き換えた数字列を表示します。2進数の文字列表記を作るときは、下の桁から求めて最後に反転する方が簡単です。

```cpp
void solve(std::istream& is, std::ostream& os) {
    using Num = long long int;
    Num n {0};
    is >> n;
    --n;

    size_t n_bits = 10;
    std::vector<Num> digits;
    for(decltype(n_bits) i{0}; i<n_bits; ++i) {
        const auto digit = ((n & 1) > 0) ? 7 : 4;
        digits.push_back(digit);
        n >>= 1;
    }

    for(auto it = digits.rbegin(); it != digits.rend(); ++it) {
        os << *it;
    }
    os << "\n";

    return;
}
```

### C06

正N角形がまず思い浮かびました。他もあるのかないのかは確認していません。

### C07

限られた予算でできるだけたくさんの品物を買うには、安い物から順番に買えばいいです。

1. 品物の値段を昇順(配列の先頭は一番安く、配列の後に行くほど高い)に並べ替えます。同じ値段の品物が複数あれば連続します。
1. 品物の値段の累積和`cumsum`を取ります。これで何個品物を買うのに最低何円かかるかが分かります。一個も買わなければ0円で0個買うことになります。C++の配列は0-based indexing (先頭の添え字が0)なので好都合です。
1. C++なら`std::upper_bound`を使って、合計がX円より値段の高い、最低の品数を指すイテレータ`it`を見つけます。
1. `(it - 1) - cumsum.begin()` が、X円以下で最大の品数です(`cumsum`の添え字の番号と一致します)。ただし`it`が`cumsum.begin()`を指しているときはその前には行けないので特別扱いします。`it`が`cumsum.end()`のときは、その前は最後の要素なので問題ありません。

### C08

個人的には、解くのに時間が掛かった問題です。

1. 1等のくじが一つだけあれば、それが1等の当選番号です。1等のくじが複数あれば、1等の当選番号は決定不能です。
1. 1等のくじが一つもなければ、0000から9999まで総当たりで検索します。$N=100$なので時間切れにはならないでしょう。
1. ある番号に対して、引いたくじがすべての2等または3等のくじであることに反しなければ、その番号を1等のくじの候補とします。
1. 1等の候補になる番号が一つだけならそれが1等の当選番号です。それ以外なら1等の当選番号は決定不能です。

ある番号に対してあるくじが2等であると言えるとは、数字が一つだけ異なることです。同様に3等のくじであると言えるとは、番号が二つ以上異なることです。

数独のように、ある桁のある数字になりうる候補はなんだろう、と考えたら解けませんでした。時には力づくも大事です。数独もある程度ますが埋まったらバックトラッキングの方が速いですし。

### C09

A16にある動的計画法そのものです。ここで重要な前提として、勉強できるときにわざわざさぼることはしない(合理的である)と仮定します。i日目に注目して以下の通りになります。

- i-1日目はお休み
- i-2日目は勉強できるが、大局的にみて勉強しない方が、夏休み全体の実力は上がるかもしれない
- i-3日目は勉強できるが、大局的にみて勉強しない方が、夏休み全体の実力は上がるかもしれない
- i-4日目に勉強しているなら、i-2日目も勉強しているはず
- i-5日目に勉強しているなら、i-2日目とi-3日目のどちらか一方は勉強しているはず(両方はできない)
- i-6日目以前も同様

ですので、i-1日目(今日は休み), i-2日目と今日, i-3と今日、の三通りの実力の最大値から、動的計画法でi日目までの実力の最大値を求めます。iが3以下のときi-2日目とi-3日目はないかもしれないのでそれらは特別扱いします。

### C10

最初の列は4x3の12通り、二番目の列は7通り(描くとわかります)、三番目の列は一番目の列とは無関係に7通りです。一般的に、W列あれば$12*7^{W-1}$通りになります。これをダブリング(A57)で実装します。

### C11

ドント式において、ある政党の最低得票を以下のように定義します。

- 議席を1以上確保した政党は、政党の得票数/獲得議席数
- 議席を確保できなかったした政党については定義しない

ここからすべての政党の最低得票(ボーダー)を求めます。ボーダーが上がると総議席数は同じか減る(狭義短調減少)、ボーダーが下がると総議席数は同じか増える(狭義短調増加)です。なので総議席数がK議席になるボーダーを二分探索で求めます。

ここで素の議席数を整数で演算すると、除算の切り捨てが原因で誤答することがあります。問題文を読み返します。

- ボーダーとなる「票数÷議席数」の値は1を超え$10^9$未満である
- ボーダーとなる「票数÷議席数」と、次点の「票数÷議席数」の相対誤差は$10^{−6}$を超える

相対誤差が生じないように、素の議席数に$10^{6}$を掛けておきます。こうしても議席数は、long long intで表現可能な範囲を超えません。この方法はA73と同じです。あるいは固定小数点演算に慣れている人なら思いつくでしょう。

### C12

私はこれを正しく実装するのに丸一日以上かかりました。なかなかWAが解決できませんでした。

まず問題を以下のように読み替えます。

- 「小説の良さ」を最大化するのではなく、「小説の悪さ」を最小化する。つまり異なる章に存在する繋がり(切れるつながり)の個数を最小化する。
- K章に分割するのではなく、K-1章の切れ目を置く。つまりこのページで章が終わりというページをK-1個求める

小節がまるごと1章なら、切れるつながりはないので、小説の悪さは0、小説の良さはMです。以後Kは2以上として、このようにすると、1ページ目で1章で終わる状況を上手く表現できます。最終ページでは必ず章が終わりますが、N-1ページ目がK-1章の終わりなら、最終章K章はNページだけで構成するということです。

これを二次元動的計画法で解きます。縦軸にページ数、横軸に章の切れ目の数、値は切れるつながりの個数とします。例えば3ページ目で第1章を終えて区切ったときは以下のようになります。1..3ページから4ページ目以降につながっているとき、切れるつながりとしてその個数を数えます。1..3ページから1..3ページ目につながっているときは、共に第1章にあるのでつながりは切れません。4ページ目以降のことはまだ考えません。

```
+++-----------
```

ついで7ページ目で第2章を終えます。4..7ページから8ページ目以降につながっているとき、異なる章に存在する繋がりとしてその個数を数えます。4..7ページから4..7ページ目につながっているときは、ともに第2章にあるのでつながりは切れません。ここで1..3ページから8ページ目以降につながっているとき、その個数はもう数えてあるので改めて数えません。これが動的計画法の原動力です。

```
+++----=======
```

7ページ目で第2章を終えるとき、切れるつながりの最小値は、6通りについて以下の和を求めたときの最小値です。
- 1..6ページ目で第1章を終えたときの第1章で切れるつながりの最小値
- 2章の開始(2..7ページ目)から8ページ目以降につながっているときに、第2章で切れるつながり

これを1ページずつ、1章ずつ増やすと、NページにK-1回切れ目を置いたときに切れるつながりの最小値が求まります。私のコードは繰り返しが多くてとても冗長なので、実装に慣れた方のコードをご覧ください。

### C13

A30にある、除算をmod 1000000007 の下で求める実装が必要です。まだ実装していなければ実装しましょう。

これができればC04と同様に、Aが mod 1000000007 の下でPの約数かどうか調べ、約数なら mod 1000000007 になる数の個数を増やして、最後に二つの約数の組み合わせが何個あるか数え上げます。例によって、平方数の扱いに注意します。

私のコードに約数を求めるコードが残っていますが、使い道がないので後で消します。

### C14

A64とB64にある、ダイクストラ法の実装が必要です。まだ実装していなければ実装しましょう。

最初にダイクストラ法で、交差点1から他の交差点までの最短距離を求めます。このとき通ると決めた経路を消しておかないとTLEします。C++のSTLでは`erase`を上手く使う必要があります。コンテナをイテレータで走査中にコンテナを増減するとイテレータが無効領域を指して未定義動作を引き起こすことがあります。こうなるとデバッグが厄介です。

```cpp
it = sub_edges.erase(it);
```

次に経路を消す前の入力のグラフを使って、交差点1から他の交差点までの最短距離だけからなるグラフを作ります。後者のグラフを交差点Nから交差点1まで深さ優先探索して、探索経路にある交差点を集める(`std::set`に追加する)と、集めた交差点の数が問題の答えです。

実装上の注意として、経路(`path`)のコピーは時間が掛かるので、深さ優先探索をするときに一段深く潜るときは交差点をpushし、浅くなるときは交差点をpopします。`path` をコピーするとTLEすることがあります。

```cpp
using UniqueNodes = std::set<Num>;
using Path = std::vector<Num>;
void traverse(std::multimap<Num, Num>& route, UniqueNodes& nodes, Path& path, Num from, Num to) {
    path.push_back(next);
    // DFSを一段深く潜る
    traverse(route, nodes, path, next, to);
    path.pop_back();
 }
```

### C15

A39を思い出せば、ほぼ解けたも同然です。

ある会議に絶対出席するとして、それ以外の会議に出られる最大の回数は、以下の合計です。

- 絶対出る会議1回
- 絶対出る会議の前に、最大で出られる回数(A39そのもの)
- 絶対出る会議の後に、最大で出られる回数(A39で、開始終了時刻を反転させたもの)

ここで実装上の工夫が要ります。

- 2つの出席する会議の間にはK秒以上空けるのは、会議の終了時刻をK/2秒延ばすことと同じです
- K/2秒が秒未満切り捨てにならないよう、時刻を2倍します
- 会議の開始時刻の最小値が-K秒にならないよう、開始時刻をK秒足します。分かりやすくなるのでそうしますが、必須ではありません。

こうするとそれぞれの会議は、開始時刻$L*2$、終了時刻$R*2+K*2$、一日は$0..((86400+K)*2)$秒になります。あとはA39と同様に解けます。

### C16

最初にグラフを思い浮かべます。以下の方法を実装したらTLEしました。

- 点(ノード)をフライト、辺(エッジ)をあるフライトAからあるフライトBへ乗り継ぎ可能である、とする
- 乗り継ぎ可能とはフライトAの到着地=フライトBの出発地かつ、フライトAの到着時刻+K<=フライトBの出発時刻
- 乗り継ぎ前になりうるフライトに対して、ダミーのsourceノードから辺を張る
- 乗り継ぎ後になりうるが乗り継ぎ前になりえないフライトに対して、ダミーのsinkノードに辺を張る
- Sourceノードからsinkノードへの最長距離を深さ優先探索で求めると、それが最大乗り継ぎ回数+1である

答えは正しそうですが、計算量が$O(M^2)$なので、大きなMだとTLEします。なのでグラフを直接構成する代わりに、ある空港で時刻までに何回乗れるかという表を保持します。

1. すべてのフライトを到着時刻の昇順で以下を実行する。処理量は$O(M*log(M))$
1. あるフライトFの出発地である空港Dに到着するフライトがなければ、フライトFに乗り継ぐ方法はないので、0回乗ってからフライトFで1回乗った、ということにする
1. そうでなければ、フライトFの出発地Dの(出発時刻-k)以前に到着するフライトのうち、出発地Dに来るまでの乗り継ぎ回数が最多の便から乗り継いだことにする。フライトを到着時刻の昇順で処理しているので、そのようなフライトがあるなら既に乗り継ぎ回数は分かっている

処理3の私の実装が全探索になってしまってます。ある時刻までに乗り継ぎ回数が最多でないフライトを残す必要はないので、もっと効率よく実装できそうです。

### C17

キューを二つ使って実装します。二つのキューの要素数は高々1違うようにすれば、行列の中央に挿入する処理は、前半キューの末尾か後半キューの先頭のどちらかに挿入する処理にできます。

std::dequeは, top, push, pop, size の計算量が定数なので、std::dequeを使えば計算量$O(Q)$を達成できます。ただしC++ STLの計算量(time complexity)はデータ構造に対するアルゴリズムの計算量で、実際にはヒープからメモリを確保するかもしれない時間が処理時間に加わります。それも含めて$O(Q)$を達成したいのであれば、C配列を使うかstd::vector::reserveを使ってあらかじめメモリを確保するとよいでしょう。

### C18

私は解説を見ずに解けませんでした。公式の解説をご覧下さい。

## C19

私はこれで合っていると思うのですが、証明に反例があるかもしれません。長文です。

### 前処理

1. 同じ地点に複数のガソリンスタンドがあるときは、最安値のガソリンスタンドを残して他は消します
1. 問題設定ではゴールにガソリンスタンドはありませんが、ゴールに仮のガソリンスタンドがあると想定すると実装が楽です
1. ガソリンスタンドを先頭から近い順に並べ替えます
1. スタートから最初のガソリンスタンドの距離、およびガソリンスタンド間の距離がkを超えていたらガソリンが尽きるので、その場で"-1"を出力して終わります。ゴールにガソリンスタンドがあると最後の(真の)ガソリンスタンドを特別扱いしなくて済むのでデバッグしやすいです。

### Small cases

N<=100, L<=100 は、二次元動的計画法で解けます。

縦軸をガソリンスタンド、横軸をそのガソリンスタンドを出発する時点での積載量(0以上k以下の整数)、値をこれまでのガソリン代とします。

前のガソリンスタンドを出発する時点での積載燃料 - ガソリン消費(距離と同じ) + このガソリンスタンドでの給油した後の積載量(0以上)のすべての組み合わせに対して、前のガソリンスタンドを出発する時点ガソリン代 + このガソリンスタンドでの給油代を最小化するよう値を選べばよいです。ガソリンスタンドに到着したときより出発する方がガソリンが少ないことはあり得ないので、その場合はガソリン代を無限大にします。

この方法だと、計算量は$O(L^3)$で解けます。

### Large cases (前半)

私の発想はしゃくとり法(A13) + 起算日(A60) + ダイクストラ法の$O(N*log(N))$解法ですが、慣れている人はいろいろご存じでしょう。

現在地のガソリンスタンドAから到達可能(前方距離がk以内)のガソリンスタンド群Sを考えます。ガソリンスタンドAのガソリン単価pより、値段が高いガソリンスタンドを+、値段が同じか安いガソリンスタンドを-とします。

```
A
p++--+-
```

値段が同じか安いガソリンスタンドが一つでもあれば、そのうち最も近いガソリンスタンドBに行きます。ガソリンスタンド群Sの最安値とは限りません。ガソリンスタンドBについたら、新たに到達なガソリンスタンドが先に見えますが、ガソリンスタンドBで給油すると全体最適(ゴール時のガソリン代が最安値)ならすればよく、そうでなければ給油しなければいいので停まっても損はしません。

```
A  B
...q++---++
```

ガソリンスタンドAで給油する量は、Bまで到達するために最低限必要な量(最低以上積載しているなら無給油)です。ゴールに仮のガソリンスタンドがあると、この処理を楽に書けます。ガソリンスタンドA, Bをしゃくとり法で求めれば、計算量は$O(L)$です。

### Large cases (後半)

上記が成り立たないのは、現在地のガソリンスタンドAから到達可能(前方距離がk以内)のガソリンスタンド群Sに、ガソリンスタンドAのガソリン単価pより、値段が安いガソリンスタンドが一つもないときです。このときはガソリンスタンドAで給油できるだけたくさん給油します。必要な量は積めるだけ積むかゴールまで min(K, L - ガソリンスタンドAの位置) ですので、積載量との差(0以上)を給油します。

次のガソリンスタンドは、ガソリンスタンド群Sのうち最安値のガソリンスタンドBです。このときしゃくとり法の右(ゴールに近い側)をスタート側に巻き戻すと、計算結果は正しいですが計算時間が$O(L^2)$になってTLEすることがあります。巻き戻すと、距離kの範囲にある同じガソリンスタンド群Sを何度も調べるからです。

そのためしゃくとり法で調べた範囲の、現在地より高いガソリンスタンドを優先度キューに積んで、現在地よりは高いが優先度キューで最も安いガソリンスタンドを$O(1)$で取り出せるようにします。優先度キューから取り除く計算量は$O(log(L))$なので、この問題の最悪計算量は$O(L*log(L))$になります。現在地より安いガソリンスタンドが見つかったら優先度キューを空にします。

厄介なのは証明ですね。局所最適なのは明らかですが、全体最適でもあることを証明する必要があります。ガソリンスタンド群Sの最後ガソリンスタンドをCとして、その次をガソリンスタンドD、Bから距離k以内でCより遠い最も遠いガソリンスタンドEがあるならそう定義します。CがゴールならDとEについて考えるまでもなく、この局所最適は全体最適でもあります。

Bについた時点でDとの距離がKより長ければまだDは見えないので、B-Cの関係はA-Cの関係と同じです。単に給油せずCまでで最安値のガソリンスタンドに停まります。

```
A     CD
p++++++
A  B  CD
...q+++
```

ガソリンスタンドBについた時点で、ガソリンスタンドBより安いガソリンスタンドがEまであればlarge case前半と同じです。

```
A     C
p++++++
A  B  CD
...q+++-

A     C
p++++++
A  B  CD  E
...q++++-++
```

そうでなければB-Eの関係はA-Cの関係と同じです。ここはもう少しいい証明が必要です。

```
A     C
p++++++
A  B  CD  E
...q+++++++
```

最後にC++のstd::priority_queueの使い方には注意があります。

- topは最も大きな値を取りだします。最も小さな値を取りだすときは、大小の定義を逆にします。
- priority_queueオブジェクトを一呼び出しで空にする方法はありません。その代わりに、空のオブジェクトと`std::swap`で交換します。

```cpp
struct StationPrice {
    Num price {0};
    Num index {0};
    bool operator<(const StationPrice& rhs) const {
        return std::tie(price, index) > std::tie(rhs.price, rhs.index);
    }
};

{
    std::priority_queue<StationPrice> zero;
    std::swap(candidates, zero);
}
```

## C20

私はまだ解いていませんし、ヒューリスティック型課題なので正答はなく改善があるという問題です。公式の解説をご覧下さい。
